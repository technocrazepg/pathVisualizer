{"version":3,"sources":["PathfindingVisualizer/Node/Node.jsx","algorithms/dijkstra.js","PathfindingVisualizer/AlgoInfo/Dijkstra.jsx","PathfindingVisualizer/AlgoInfo/Bfs.jsx","PathfindingVisualizer/AlgoInfo/Dfs.jsx","PathfindingVisualizer/PathfindingVisualizer.jsx","algorithms/bfs.js","algorithms/dfs.js","App.js","serviceWorker.js","index.js"],"names":["Node","this","props","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","row","extraClassName","id","className","Component","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","Dijkstra","Bfs","Dfs","PathfindingVisualizer","getInitialGrid","rowCount","state","ROW_COUNT","colCount","COLUMN_COUNT","initialGrid","currentRow","createNode","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","distanceToFinishNode","Math","abs","isNode","mouseIsPressed","isRunning","isStartNode","isFinishNode","isWallNode","currRow","currCol","algoInfo","handleMouseDown","bind","handleMouseLeave","toggleIsRunning","setState","isGridClear","document","getElementById","newGrid","getNewGridWithWallToggled","clearGrid","nodeClassName","slice","algo","nextNodesStack","currentNode","nextNode","bfs","pop","dfs","nodesInShortestPathOrder","unshift","getNodesInShortestPathOrder","animate","i","setTimeout","animateShortestPath","onMouseLeave","map","rowIdx","key","nodeIdx","handleMouseEnter","handleMouseUp","type","onClick","clearWalls","visualize","newNode","App","Boolean","window","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.2ca87404.chunk.js","sourcesContent":["import React, {Component} from 'react';\r\n\r\nimport './Node.css';\r\n\r\nexport default class Node extends Component {\r\n  render() {\r\n    const {\r\n      col,\r\n      isFinish,\r\n      isStart,\r\n      isWall,\r\n      onMouseDown,\r\n      onMouseEnter,\r\n      onMouseUp,\r\n      row,\r\n    } = this.props;\r\n    \r\n    const extraClassName = isFinish\r\n      ? 'node-finish'\r\n      : isStart\r\n      ? 'node-start'\r\n      : isWall\r\n      ? 'node-wall'\r\n      : '';\r\n\r\n    return (\r\n      <td\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${extraClassName}`}\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={() => onMouseUp()}></td>\r\n    );\r\n  }\r\n}\r\n","// Returns all nodes in the order in which they were visited.\r\n// Make nodes point back to their previous node so that we can compute the shortest path\r\n// by backtracking from the finish node.\r\n\r\nexport function dijkstra(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid); // Q: different from using grid or slice of grid???\r\n\r\n  while (unvisitedNodes.length) {\r\n    sortNodesByDistance(unvisitedNodes);\r\n    const closestNode = unvisitedNodes.shift();\r\n    // If we encounter a wall, we skip it.\r\n    if (!closestNode.isWall) {\r\n      // If the closest node is at a distance of infinity,\r\n      // we must be trapped and should stop.\r\n      if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n      closestNode.isVisited = true;\r\n      visitedNodesInOrder.push(closestNode);\r\n      if (closestNode === finishNode) return visitedNodesInOrder;\r\n      updateUnvisitedNeighbors(closestNode, grid);\r\n    }\r\n  }\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    neighbor.distance = node.distance + 1;\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const {col, row} = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n","import React from 'react'\r\n\r\nfunction Dijkstra() {\r\n  return (\r\n    <div className='text-justify'>\r\n        <p>Djikstra used this property in the opposite direction i.e we overestimate the distance of each vertex from the starting vertex. Then we visit each node and its neighbors to find the shortest subpath to those neighbors. The algorithm uses a greedy approach in the sense that we find the next best solution hoping that the end result is the best solution for the whole problem.</p>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default Dijkstra","import React from 'react'\r\n\r\nfunction Bfs() {\r\n  return (\r\n    <div className='text-justify'>\r\n        <p>Breadth-first search is a graph traversal algorithm that starts traversing the graph from the root node and explores all the neighboring nodes. Then, it selects the nearest node and explores all the unexplored nodes. While using BFS for traversal, any node in the graph can be considered as the root node.There are many ways to traverse the graph, but among them, BFS is the most commonly used approach. It is a recursive algorithm to search all the vertices of a tree or graph data structure. BFS puts every vertex of the graph into two categories - visited and non-visited. It selects a single node in a graph and, after that, visits all the nodes adjacent to the selected node.</p>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default Bfs","import React from 'react'\r\n\r\nfunction Dfs() {\r\n  return (\r\n    <div className='text-justify'>\r\n        <p>It is a recursive algorithm to search all the vertices of a tree data structure or a graph. The depth-first search (DFS) algorithm starts with the initial node of graph G and goes deeper until we find the goal node or the node with no children.Because of the recursive nature, stack data structure can be used to implement the DFS algorithm. The process of implementing the DFS is similar to the BFS algorithm.</p>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default Dfs","import React, {Component} from 'react';\r\nimport Node from './Node/Node';\r\nimport {dijkstra} from '../algorithms/dijkstra';\r\nimport {dfs} from '../algorithms/dfs';\r\nimport {bfs} from '../algorithms/bfs';\r\nimport Dijkstra from './AlgoInfo/Dijkstra';\r\nimport Bfs from './AlgoInfo/Bfs';\r\nimport Dfs from './AlgoInfo/Dfs';\r\nimport './PathfindingVisualizer.css';\r\n\r\nexport default class PathfindingVisualizer extends Component {\r\n  constructor() {\r\n    super();\r\n    this.state = {\r\n      grid: [],\r\n      START_NODE_ROW: 5,\r\n      FINISH_NODE_ROW: 5,\r\n      START_NODE_COL: 5,\r\n      FINISH_NODE_COL: 15,\r\n      mouseIsPressed: false,\r\n      ROW_COUNT: 20,\r\n      COLUMN_COUNT: 30,\r\n      isRunning: false,\r\n      isStartNode: false,\r\n      isFinishNode: false,\r\n      isWallNode: false, // xxxxxxx\r\n      currRow: 0,\r\n      currCol: 0,\r\n      algoInfo: \"\",\r\n    };\r\n\r\n    this.handleMouseDown = this.handleMouseDown.bind(this);\r\n    this.handleMouseLeave = this.handleMouseLeave.bind(this);\r\n    this.toggleIsRunning = this.toggleIsRunning.bind(this);\r\n  }\r\n\r\n  componentDidMount() {\r\n    const grid = this.getInitialGrid();\r\n    this.setState({grid});\r\n  }\r\n\r\n  toggleIsRunning() {\r\n    this.setState({isRunning: !this.state.isRunning});\r\n  }\r\n\r\n  /******************** Set up the initial grid ********************/\r\n  getInitialGrid = (\r\n    rowCount = this.state.ROW_COUNT,\r\n    colCount = this.state.COLUMN_COUNT,\r\n  ) => {\r\n    const initialGrid = [];\r\n    for (let row = 0; row < rowCount; row++) {\r\n      const currentRow = [];\r\n      for (let col = 0; col < colCount; col++) {\r\n        currentRow.push(this.createNode(row, col));\r\n      }\r\n      initialGrid.push(currentRow);\r\n    }\r\n    return initialGrid;\r\n  };\r\n\r\n  createNode = (row, col) => {\r\n    return {\r\n      row,\r\n      col,\r\n      isStart:\r\n        row === this.state.START_NODE_ROW && col === this.state.START_NODE_COL,\r\n      isFinish:\r\n        row === this.state.FINISH_NODE_ROW &&\r\n        col === this.state.FINISH_NODE_COL,\r\n      distance: Infinity,\r\n      distanceToFinishNode:\r\n        Math.abs(this.state.FINISH_NODE_ROW - row) +\r\n        Math.abs(this.state.FINISH_NODE_COL - col),\r\n      isVisited: false,\r\n      isWall: false,\r\n      previousNode: null,\r\n      isNode: true,\r\n    };\r\n  };\r\n\r\n  /******************** Control mouse events ********************/\r\n  handleMouseDown(row, col) {\r\n    if (!this.state.isRunning) {\r\n      if (this.isGridClear()) {\r\n        if (\r\n          document.getElementById(`node-${row}-${col}`).className ===\r\n          'node node-start'\r\n        ) {\r\n          this.setState({\r\n            mouseIsPressed: true,\r\n            isStartNode: true,\r\n            currRow: row,\r\n            currCol: col,\r\n          });\r\n        } else if (\r\n          document.getElementById(`node-${row}-${col}`).className ===\r\n          'node node-finish'\r\n        ) {\r\n          this.setState({\r\n            mouseIsPressed: true,\r\n            isFinishNode: true,\r\n            currRow: row,\r\n            currCol: col,\r\n          });\r\n        } else {\r\n          const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n          this.setState({\r\n            grid: newGrid,\r\n            mouseIsPressed: true,\r\n            isWallNode: true,\r\n            currRow: row,\r\n            currCol: col,\r\n          });\r\n        }\r\n      } else {\r\n        this.clearGrid();\r\n      }\r\n    }\r\n  }\r\n\r\n  isGridClear() {\r\n    for (const row of this.state.grid) {\r\n      for (const node of row) {\r\n        const nodeClassName = document.getElementById(\r\n          `node-${node.row}-${node.col}`,\r\n        ).className;\r\n        if (\r\n          nodeClassName === 'node node-visited' ||\r\n          nodeClassName === 'node node-shortest-path'\r\n        ) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  handleMouseEnter(row, col) {\r\n    if (!this.state.isRunning) {\r\n      if (this.state.mouseIsPressed) {\r\n        const nodeClassName = document.getElementById(`node-${row}-${col}`)\r\n          .className;\r\n        if (this.state.isStartNode) {\r\n          if (nodeClassName !== 'node node-wall') {\r\n            const prevStartNode = this.state.grid[this.state.currRow][\r\n              this.state.currCol\r\n            ];\r\n            prevStartNode.isStart = false;\r\n            document.getElementById(\r\n              `node-${this.state.currRow}-${this.state.currCol}`,\r\n            ).className = 'node';\r\n\r\n            this.setState({currRow: row, currCol: col});\r\n            const currStartNode = this.state.grid[row][col];\r\n            currStartNode.isStart = true;\r\n            document.getElementById(`node-${row}-${col}`).className =\r\n              'node node-start';\r\n          }\r\n          this.setState({START_NODE_ROW: row, START_NODE_COL: col});\r\n        } else if (this.state.isFinishNode) {\r\n          if (nodeClassName !== 'node node-wall') {\r\n            const prevFinishNode = this.state.grid[this.state.currRow][\r\n              this.state.currCol\r\n            ];\r\n            prevFinishNode.isFinish = false;\r\n            document.getElementById(\r\n              `node-${this.state.currRow}-${this.state.currCol}`,\r\n            ).className = 'node';\r\n\r\n            this.setState({currRow: row, currCol: col});\r\n            const currFinishNode = this.state.grid[row][col];\r\n            currFinishNode.isFinish = true;\r\n            document.getElementById(`node-${row}-${col}`).className =\r\n              'node node-finish';\r\n          }\r\n          this.setState({FINISH_NODE_ROW: row, FINISH_NODE_COL: col});\r\n        } else if (this.state.isWallNode) {\r\n          const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n          this.setState({grid: newGrid});\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  handleMouseUp(row, col) {\r\n    if (!this.state.isRunning) {\r\n      this.setState({mouseIsPressed: false});\r\n      if (this.state.isStartNode) {\r\n        const isStartNode = !this.state.isStartNode;\r\n        this.setState({isStartNode, START_NODE_ROW: row, START_NODE_COL: col});\r\n      } else if (this.state.isFinishNode) {\r\n        const isFinishNode = !this.state.isFinishNode;\r\n        this.setState({\r\n          isFinishNode,\r\n          FINISH_NODE_ROW: row,\r\n          FINISH_NODE_COL: col,\r\n        });\r\n      }\r\n      this.getInitialGrid();\r\n    }\r\n  }\r\n\r\n  handleMouseLeave() {\r\n    if (this.state.isStartNode) {\r\n      const isStartNode = !this.state.isStartNode;\r\n      this.setState({isStartNode, mouseIsPressed: false});\r\n    } else if (this.state.isFinishNode) {\r\n      const isFinishNode = !this.state.isFinishNode;\r\n      this.setState({isFinishNode, mouseIsPressed: false});\r\n    } else if (this.state.isWallNode) {\r\n      const isWallNode = !this.state.isWallNode;\r\n      this.setState({isWallNode, mouseIsPressed: false});\r\n      this.getInitialGrid();\r\n    }\r\n  }\r\n\r\n  /******************** Clear Board/Walls ********************/\r\n\r\n  clearGrid() {\r\n    if (!this.state.isRunning) {\r\n      const newGrid = this.state.grid.slice();\r\n      for (const row of newGrid) {\r\n        for (const node of row) {\r\n          let nodeClassName = document.getElementById(\r\n            `node-${node.row}-${node.col}`,\r\n          ).className;\r\n          if (\r\n            nodeClassName !== 'node node-start' &&\r\n            nodeClassName !== 'node node-finish' &&\r\n            nodeClassName !== 'node node-wall'\r\n          ) {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              'node';\r\n            node.isVisited = false;\r\n            node.distance = Infinity;\r\n            node.distanceToFinishNode =\r\n              Math.abs(this.state.FINISH_NODE_ROW - node.row) +\r\n              Math.abs(this.state.FINISH_NODE_COL - node.col);\r\n          }\r\n          if (nodeClassName === 'node node-finish') {\r\n            node.isVisited = false;\r\n            node.distance = Infinity;\r\n            node.distanceToFinishNode = 0;\r\n          }\r\n          if (nodeClassName === 'node node-start') {\r\n            node.isVisited = false;\r\n            node.distance = Infinity;\r\n            node.distanceToFinishNode =\r\n              Math.abs(this.state.FINISH_NODE_ROW - node.row) +\r\n              Math.abs(this.state.FINISH_NODE_COL - node.col);\r\n            node.isStart = true;\r\n            node.isWall = false;\r\n            node.previousNode = null;\r\n            node.isNode = true;\r\n          }\r\n        }\r\n      }\r\n      this.setState({algoInfo: \"\"});\r\n    }\r\n  }\r\n\r\n  clearWalls() {\r\n    if (!this.state.isRunning) {\r\n      const newGrid = this.state.grid.slice();\r\n      for (const row of newGrid) {\r\n        for (const node of row) {\r\n          let nodeClassName = document.getElementById(\r\n            `node-${node.row}-${node.col}`,\r\n          ).className;\r\n          if (nodeClassName === 'node node-wall') {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              'node';\r\n            node.isWall = false;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /******************** Create Animations ********************/\r\n  visualize(algo) {\r\n    if (!this.state.isRunning) {\r\n      this.clearGrid();\r\n      this.toggleIsRunning();\r\n      const {grid} = this.state;\r\n      const startNode =\r\n        grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\r\n      const finishNode =\r\n        grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\r\n      let visitedNodesInOrder;\r\n      switch (algo) {\r\n        case 'Dijkstra':\r\n          visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n          break;\r\n        case 'BFS':\r\n          visitedNodesInOrder = bfs(grid, startNode, finishNode);\r\n          break;\r\n        case 'DFS':\r\n          visitedNodesInOrder = dfs(grid, startNode, finishNode);\r\n          break;\r\n        default:\r\n          // should never get here\r\n          break;\r\n      }\r\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n      nodesInShortestPathOrder.push('end');\r\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n      this.setState({algoInfo: algo})\r\n    }\r\n  }\r\n\r\n  animate(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          this.animateShortestPath(nodesInShortestPathOrder);\r\n        }, 10 * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        const nodeClassName = document.getElementById(\r\n          `node-${node.row}-${node.col}`,\r\n        ).className;\r\n        if (\r\n          nodeClassName !== 'node node-start' &&\r\n          nodeClassName !== 'node node-finish'\r\n        ) {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            'node node-visited';\r\n        }\r\n      }, 10 * i);\r\n    }\r\n  }\r\n\r\n  /******************** Create path from start to finish ********************/\r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n      if (nodesInShortestPathOrder[i] === 'end') {\r\n        setTimeout(() => {\r\n          this.toggleIsRunning();\r\n        }, i * 50);\r\n      } else {\r\n        setTimeout(() => {\r\n          const node = nodesInShortestPathOrder[i];\r\n          const nodeClassName = document.getElementById(\r\n            `node-${node.row}-${node.col}`,\r\n          ).className;\r\n          if (\r\n            nodeClassName !== 'node node-start' &&\r\n            nodeClassName !== 'node node-finish'\r\n          ) {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              'node node-shortest-path';\r\n          }\r\n        }, i * 40);\r\n      }\r\n    }\r\n  }\r\n  \r\n  render() {\r\n    const {grid, mouseIsPressed} = this.state;\r\n    return (\r\n      <div className='row'>\r\n      <div className='col-md-8'>\r\n        <table\r\n          className=\"grid-container\"\r\n          onMouseLeave={() => this.handleMouseLeave()}>\r\n          <tbody className=\"grid\">\r\n            {grid.map((row, rowIdx) => {\r\n              return (\r\n                <tr key={rowIdx}>\r\n                  {row.map((node, nodeIdx) => {\r\n                    const {row, col, isFinish, isStart, isWall} = node;\r\n                    return (\r\n                      <Node\r\n                        key={nodeIdx}\r\n                        col={col}\r\n                        isFinish={isFinish}\r\n                        isStart={isStart}\r\n                        isWall={isWall}\r\n                        mouseIsPressed={mouseIsPressed}\r\n                        onMouseDown={(row, col) =>\r\n                          this.handleMouseDown(row, col)\r\n                        }\r\n                        onMouseEnter={(row, col) =>\r\n                          this.handleMouseEnter(row, col)\r\n                        }\r\n                        onMouseUp={() => this.handleMouseUp(row, col)}\r\n                        row={row}></Node>\r\n                    );\r\n                  })}\r\n                </tr>\r\n              );\r\n            })}\r\n          </tbody>\r\n        </table>\r\n        <button\r\n          type=\"button\"\r\n          className=\"btn btn-danger\"\r\n          onClick={() => this.clearGrid()}>\r\n          Clear Grid\r\n        </button>\r\n        <button\r\n          type=\"button\"\r\n          className=\"btn btn-warning\"\r\n          onClick={() => this.clearWalls()}>\r\n          Clear Walls\r\n        </button>\r\n        <button\r\n          type=\"button\"\r\n          className=\"btn btn-primary\"\r\n          onClick={() => this.visualize('Dijkstra')}>\r\n          Dijkstra's\r\n        </button>\r\n        <button\r\n          type=\"button\"\r\n          className=\"btn btn-primary\"\r\n          onClick={() => this.visualize('BFS')}>\r\n          Bread First Search\r\n        </button>\r\n        <button\r\n          type=\"button\"\r\n          className=\"btn btn-primary\"\r\n          onClick={() => this.visualize('DFS')}>\r\n          Depth First Search\r\n        </button>\r\n      </div>\r\n      <div className='col-md-4 d-flex flex-column justify-content-center'>\r\n        <h1>{this.state.algoInfo || \"Algorithm information here...\"}</h1>\r\n        {this.state.algoInfo === \"Dijkstra\" && <Dijkstra />}\r\n        {this.state.algoInfo === \"BFS\" && <Bfs />}\r\n        {this.state.algoInfo === \"DFS\" && <Dfs />}\r\n      </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\n/******************** Create Walls ********************/\r\nconst getNewGridWithWallToggled = (grid, row, col) => {\r\n  // mouseDown starts to act strange if I don't make newGrid and work off of grid instead.\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  if (!node.isStart && !node.isFinish && node.isNode) {\r\n    const newNode = {\r\n      ...node,\r\n      isWall: !node.isWall,\r\n    };\r\n    newGrid[row][col] = newNode;\r\n  }\r\n  return newGrid;\r\n};\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// Only works when called after the pathfinding methods.\r\nfunction getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","// Returns all nodes in the order in which they were visited.\r\n// Make nodes point back to their previous node so that we can compute the shortest path\r\n// by backtracking from the finish node.\r\n\r\nexport function bfs(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  let nextNodesStack = [startNode];\r\n  while (nextNodesStack.length) {\r\n    const currentNode = nextNodesStack.shift();\r\n    if (currentNode === finishNode) return visitedNodesInOrder;\r\n\r\n    if (\r\n      !currentNode.isWall &&\r\n      (currentNode.isStart || !currentNode.isVisited)\r\n    ) {\r\n      currentNode.isVisited = true;\r\n      visitedNodesInOrder.push(currentNode);\r\n      const {col, row} = currentNode;\r\n      let nextNode;\r\n      if (row > 0) {\r\n        nextNode = grid[row - 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (row < grid.length - 1) {\r\n        nextNode = grid[row + 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (col > 0) {\r\n        nextNode = grid[row][col - 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (col < grid[0].length - 1) {\r\n        nextNode = grid[row][col + 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  // return visitedNodesInOrder;\r\n}\r\n","// Returns all nodes in the order in which they were visited.\r\n// Make nodes point back to their previous node so that we can compute the shortest path\r\n// by backtracking from the finish node.\r\n\r\nexport function dfs(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  const nextNodesStack = [];\r\n  nextNodesStack.push(startNode);\r\n  while (nextNodesStack.length) {\r\n    const currentNode = nextNodesStack.pop();\r\n\r\n    if (currentNode === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    if (\r\n      !currentNode.isWall &&\r\n      (currentNode.isStart || !currentNode.isVisited)\r\n    ) {\r\n      currentNode.isVisited = true;\r\n      visitedNodesInOrder.push(currentNode);\r\n\r\n      const {col, row} = currentNode;\r\n      let nextNode;\r\n      if (row > 0) {\r\n        nextNode = grid[row - 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (row < grid.length - 1) {\r\n        nextNode = grid[row + 1][col];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (col > 0) {\r\n        nextNode = grid[row][col - 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n      if (col < grid[0].length - 1) {\r\n        nextNode = grid[row][col + 1];\r\n        if (!nextNode.isVisited) {\r\n          nextNode.previousNode = currentNode;\r\n          nextNodesStack.push(nextNode);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n","import React from 'react';\r\nimport './App.css';\r\nimport PathfindingVisualizer from './PathfindingVisualizer/PathfindingVisualizer';\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <PathfindingVisualizer></PathfindingVisualizer>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}